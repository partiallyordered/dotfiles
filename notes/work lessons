When something is well-designed and well-implemented, and doesn't break, nobody knows about it. In
terms of selfish, short-term career progression, it pays to have something fail occasionally and be
the hero/firefighter who saves the day. This is an unpleasant way to work. Just build good stuff in
the first place and leave if you're not appreciated. Sometimes it's possible to make up for this
effect with self-promotion.

Interpersonal communication during development is overhead that is fundamentally not generating
product. This is *not* to say that communication is a waste of time. A process/system that does not
minimise unnecessary communication is wasting resources. Some organisations seem to take the view
that visible communication is an unmitigated good, and therefore there should be more of it. This
is at odds with producing.
Obvious examples of good communication:
- the design phase
    - often input from others improves the result (quality/speed)
    - need to actually be solving a business problem, not something else
- debugging: it's easy to focus on the wrong thing, sometimes a fresh set of eyes/questions is
    extremely useful
- relationships are built on communication, and it's nice to have friendly relationships with
    colleagues.

Developers must be able to run and interact with the software in a sufficiently representative
environment, with relative ease. If that's not possible, expect software quality and development
velocity to drop progressively.

Sometimes the business has to be told no, they can't have that quick hack. If they don't like that,
work for someone else.

There is no substitute for integration tests run before the code is released.

Reviews are about getting the first reader (non-writer) of your code to read and understand your
code. This is very important because, as the writer of your code, you're very poorly positioned to
analyse it as a reader. Remember the adage: "code is read 10x more than it's written", so it's very
important that it's accessible as a reader.

The biggest cost of code is maintenance, not implementation. Code that isn't written is code that
doesn't need to be maintained. Do you *really* need that in-house widget library?

Interfaces between teams should be defined in code as much as possible. This is one of the biggest
strengths of Kubernetes when used as an industry-standard ops/dev interface.

Work with the primitives of your system. If the primitives of your system are users and medical
records and appointments, create interfaces (including development interfaces!) that work with
these primitives- *not* HTTP requests. IOW, Postman and curl are fine for exploratory usage, but
you'll work *much* more effectively if you can create a user with
```sh
$ my-cli create user --username jimmy --password correct-horse-battery-staple
```
or
```rust
const client = Client::new();
client.create_user("jimmy", "correct-horse-battery-staple");
```
instead of
```sh
$ kubectl port-forward svc/users 8080:80 &
$ curl --data '{ "blah": "blah" }' -H 'first: header' ... -H 'tenth: header' ... 'etc.'
```
or
```rust
const client = HttpClient::new();
const request = Request.builder()
    .header("first", "header")
    // ...
    .header("tenth", "header")
    .port(3030)
    .path("users")
    .method(http::Method::POST)
    .body(json::value!{
        "username": "jimmy",
        "password": "correct-horse-battery-staple",
    })
```
