
### Hardware
What's failed?
```sh
systemctl --state=failed
```
What's running?
```sh
systemctl status
```
Look for `wpa_supplicant` or `network` related services.

### Restart interfaces
First, list interfaces
```sh
ip a
```
Restart the interface by setting it down, then up:
```sh
sudo ip link set wlp1s0 down
sudo ip link set wlp1s0 up
```

### Allow via rfkill
If you see a message like
> Operation not possible due to RF-kill

Run:
```sh
sudo rfkill unblock all
```

### Routing table
Is traffic on the current machine being routed somewhere odd?
```bash
route
```

### ICMP (ping)
```bash
ping google.com # or whatever you're trying to access
```


### DNS
In the following sections, drill can normally be replaced with dig with no change of syntax. Note
that dig and drill _do not_ check `/etc/hosts` before resolving DNS, but curl _does_. If there
appears to be a discrepancy in resolution behaviour between the two, check `/etc/hosts`.

#### Try resolving google.com and clourflare.com via the services respective DNS services.
Look in the ANSWER section. If there are no results, the server couldn't resolve the name.
```bash
drill google.com @8.8.8.8
drill cloudflare.com @1.1.1.1
```

#### What's in /etc/resolv.conf?
Note that sometimes `/etc/resolv.conf` contains some additional resolution information. It's worth
inspecting the file.
Try
```bash
drill google.com @<nameserver-from-resolv-conf>
```


### TCP/UDP
#### Test connectivity
```bash
telnet google.com 80 # http
telnet google.com 443 # https
telnet github.com 22 # ssh (normally)
nc -vz google.com 80
nc -vz google.com 443
# Systems without nc, telnet, but with reasonably modern bash:
# From: https://stackoverflow.com/a/19866239
bash -c "cat < /dev/null > /dev/tcp/$hostname/$port"
bash -c "cat < /dev/null > /dev/tcp/google.com/80"
# With a timeout for failure
timeout 1 bash -c "cat < /dev/null > /dev/tcp/$hostname/$port"
```

### TLS
#### openssl s_client
Example:
```sh
openssl s_client -connect google.com:443
```
Some useful args:
```sh
openssl s_client -connect $hostname:443 -cert ./clientcert.pem -key ./clientkey.pem -CAfile ./pathfinderchain.pem
```
If you have a CA cert and some intermediate certs you can just use `cat` to combine them:
```sh
cat ./cacert.pem ./intermediate.pem ./anotherintermediate.pem > chain.pem
```
Manual
```sh
man openssl-s_client
```

#### Mutual TLS
From: https://asciinema.org/a/173370
Server:
```sh
openssl s_server -accept 8443 \
    -CAfile ca.crt.pem \
    -cert server.crt.pem \
    -key server.key.pem \
    -Verify 10 -tls1_2 -state -quiet
```
Client:
```sh
openssl s_client -connect 127.0.0.1:8443 \
    -CAfile ca.crt.pem \
    -cert client.crt.pem \
    -key client.key.pem \
    -tls1_2 -state -quiet
```


### HTTP
#### Test TCP connectivity
```bash
telnet google.com 80 # http
telnet google.com 443 # https
nc -vz google.com 80
nc -vz google.com 443
```

#### Curl tricks
##### Spoof a hostname with curl
From (much more info): https://daniel.haxx.se/blog/2018/04/05/curl-another-host/
```sh
curl --resolve example.com:8080:127.0.0.1 example.com:8080/healthz
```

#### Test a route
Note that dig and drill _do not_ check `/etc/hosts` before resolving DNS, but curl _does_. If there
appears to be a discrepancy in resolution behaviour between the two, check `/etc/hosts`.
```bash
# GET /
curl -i -w '\n' service.com
# PUT json in a local file to /users
curl service.com/users \
    -X PUT \
    --data @./local-data-file.json \
    -H 'accept: application/json' \
    -H 'content-type: application/json'
# PUT inline json in a local file to /users
curl service.com/users \
    -X PUT \
    --data '{ "name": "Jimbob" }' \
    -H 'accept: application/json' \
    -H 'content-type: application/json'
```

### Alpine Notes
Install telnet, dig:
```sh
apk update
apk add busybox-extras # telnet on Alpine 3.7+
apk add bind-tools # dig
```
