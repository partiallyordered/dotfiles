#### Inline temp file ("process substitution")
Note: `bash` or `zsh`, not `sh`
```bash
$ cat <(echo "your face")
your face
$ echo <(echo "your face")
/proc/self/fd/11
$ ls <(echo "your face")
lr-x------ /proc/self/fd/11 -> pipe:[6359673]
```
Creates a temporary file with the output of a command, returns the path as output, allowing the
recipient to read the content of the output as a file. This is called process substitution.

#### Get the directory containing the script being executed
From: https://stackoverflow.com/a/246128:
It will work as long as the last component of the path used to find the script is not a symlink
(directory links are OK). If you also want to resolve any links to the script itself, you need a
multi-line solution:
```sh
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
```

Some of the comments at the above link suggest that the below is better:
```sh
DIR=$(dirname "$(readlink -f "$0")")
```

#### Recursive text find-and-replace
From https://stackoverflow.com/a/1583282
```sh
find /home/www \( -type d -name .git -prune \) -o -type f -print0 | xargs -0 sed -i 's/subdomainA\.example\.com/subdomainB.example.com/g'
```

#### Create a file (_Here Document_)
```sh
cat > file.txt << EOF
Some text
Can contain a number of lines or whatever
Will
be
reproduced  
  verbatim (including those awful trailing spaces above)
  and substitution etc. works too: $(uuidgen)
EOF
```
Documentation: https://tldp.org/LDP/abs/html/here-docs.html
Some relevant info: https://superuser.com/a/1437122

#### Store heredoc in a variable
```sh
INTERPOLATION=this
cat <<- EOF
also works with string $INTERPOLATION
EOF
```

```sh
$ read -r -d '' VAR <<'EOF'
abc'asdf"
$(dont-execute-this)
foo"bar"''
EOF
```
From: https://stackoverflow.com/a/1655389

#### Preserve indentation in a string (using here doc)
```sh
VAR=$(cat << EOF
Some text
    Can contain a number of lines or whatever
Will
be
    reproduced  
verbatim (including those awful trailing spaces above
  and this terrible indentation)
  and substitution etc. works too: $(uuidgen)
EOF
)
```
See also: https://stackoverflow.com/questions/23929235/multi-line-string-with-extra-space-preserved-indentation

#### Trap errors
Does not affect the normal functioning of `set -e`.
```sh
trap 'echo "trapped"' ERR
# or
message() {
    echo "message"
}
trap message ERR
```

#### Wait for condition
```sh
# suppress the output by piping to /dev/null
# until kubectl get pods whatever &> /dev/null
until kubectl get pods nonexistentpod
do
    echo "Waiting for nonexistentpod"
    sleep 1
done
```

#### Loops
From https://stackoverflow.com/questions/8880603/loop-through-an-array-of-strings-in-bash
Much more there.
```sh
declare -a arr=("element1"
                "element2" "element3"
                "element4"
                )
for i in "${arr[@]}"
do
    echo "$i"
done
```
or
```sh
for i in a b c d
# or to preserve spaces
for i in 'a b' 'c d'
# or
for i in a \
         b \
         c \
         d
# or
for i in a b c d
do
    echo "$i"
done
```

#### Handle signals
In this example, we port-forward two services with kubectl then, on a received signal, kill them
both.
```sh
#!/usr/bin/env sh

export KUBECONFIG=~/.kube/config.dev

kubectl port-forward service/nginx 8000:80 &
kubectl port-forward service/redis 6379 &

clean_up() {
    # Note: this works because it attempts to kill every "word" in the output of `jobs -p`. But
    # that means it attempts to kill a lot of process ids that are totally invalid. See the output
    # of `jobs -p` to see all the gumpf it produces.
    # kill $(jobs -p)

    # This is less portable, but much nicer, and kills all subprocesses of the current session
    pkill -s $$
}

trap clean_up SIGHUP SIGINT SIGTERM

sleep infinity
```

#### Import a file of key-value pairs into environment
Given a file `vars.sh` such as
```sh
KEY=value
```
bring these variables into your environment with
```sh
. ./vars.sh
```
or
```sh
source ./vars.sh
```

To export all env vars such that subprocesses started by your shell can use them:
```
set -a
. ./vars.sh
set +a
```
`set -a` and `set +a` can go inside the script `vars.sh`.

Use a `.envrc` file with direnv or similar.

#### Make scripts suck less
Exit on errors:
```sh
set -e
```
Error when an error occurs in a pipeline:
```sh
set -o pipefail
```
Print all commands as they're about to happen:
```sh
set -x
```
Fail on missing variables:
```sh
set -u
```
More:
https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/

#### Generate a random UUID
```sh
cat /proc/sys/kernel/random/uuid
```
or
```sh
uuidgen
```

#### Checksum file
First, get the file checksum from somewhere:
```sh
$ sha256sum OpenSSL_1_1_1f.tar.gz
76b78352bc8a9aaccc1de2eb4a52fa9c7f6a5980985242ce3514b0cd208642d3  OpenSSL_1_1_1f.tar.gz
```
Now, use the generated file checksum. *Note* this uses _bash_ process substitution, a feature not
available in plain `sh`:
```bash
sha256sum -c <(echo '76b78352bc8a9aaccc1de2eb4a52fa9c7f6a5980985242ce3514b0cd208642d3  OpenSSL_1_1_1f.tar.gz') --strict
```

#### Conditionals
```sh
if [[ 1 -eq 1 ]]; then
    echo 'duh'
else
    echo 'wtf'
fi
```
```sh
if [ "1" = "1" ]; then
    echo 'duh'
else
    echo 'wtf'
fi
```
On a command result
```sh
if ./some-command > /dev/null; then
    echo "note the /dev/null pipe to suppress the output"
else
    echo "command failed"
fi
```
In a single line
```sh
if [[ "1" = "1" ]]; then echo "okay"; else echo "uh oh"; fi
```
Without an `if` (which doesn't work in zsh)
```sh
[[ 1 == 0 ]] && echo "okay" || echo "fail"
```

#### Pipe stdout and stderr
Reference: https://stackoverflow.com/questions/363223/how-do-i-get-both-stdout-and-stderr-to-go-to-the-terminal-and-a-log-file

Redirect stderr to stdout using `2>&1` then pipe:
```
ls 2>&1 | wc -l
```
(why one would run that example command is another question..)

#### Capture all output from a subshell
Reference: https://stackoverflow.com/questions/363223/how-do-i-get-both-stdout-and-stderr-to-go-to-the-terminal-and-a-log-file
```sh
{
    echo "hello"
    echo "there"
} | tee test
```

#### Read piped data into a variable
```sh
shopt -s lastpipe # run the last pipe command in the parent shell context
echo "hello" | read HELLO
echo $HELLO
```
